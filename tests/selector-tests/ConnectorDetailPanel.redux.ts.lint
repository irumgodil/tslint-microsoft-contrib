import {
  getCommandBarActiveItemStyle,
  getCommandBarContextMenuItemStyles,
  getCommandBarItemStyle
} from 'components/public/shared.styles'
import {
  IColumn,
  ICommandBarItemProps,
  IDetailsRowProps,
  IProcessedStyleSet,
  IRenderFunction,
  ISelection
} from 'office-ui-fabric-react'
import { Icon } from 'office-ui-fabric-react/lib/Icon'
import * as React from 'react'
import { ILocalizationApis, ILocalizedComponent, locApiSelector } from 'runtime/public/localization'
import { createSelector, IImmutableList, IImmutableMap } from 'runtime/public/redux'

import { ILocalizedItem } from '../../domains/domain-list/DomainListSelector.redux'
import {
  CompositeListRow,
  IActionButtonProps,
  ICompositeListFarItemOptions,
  ICompositeListRowItem
} from '../../shared/CompositeList'
import { AppState } from '../../shared/state'
import { convertFromEpochTime, convertToDateTime } from '../DateUtils'
import * as consts from '../declarations/Constants'

import * as connectorsStrings from './connectors-list.string.json'
import { IConnectorStyle } from './Connectors.style'
import { DatasetEditState, DataSetState } from './ConnectorStateEnums'
import { getRefreshScheduleOptionsForCrawlFrequency, isFileConnector } from './ConnectorUtils'
import { AclSetting, DatasetDetail, DatasetSummary, RefreshSetting } from './models'
import { CrawlFrequency } from './UDT/models'

export interface ILocalizedColumn extends IColumn, ILocalizedItem {
  classNames?: IProcessedStyleSet<IConnectorStyle>
}

//#region Command Bar selectors and actions
const commandBarLabels = {
  DisplayListMenu: 'commandBarDisplayListMenu'
}

//#region Commands
const commands = {
  DisplayListCompact: 'commandBarDisplayListCompact',
  DisplayListRelaxed: 'commandBarDisplayListRelaxed'
}

const _connectorNameColumn: ILocalizedColumn = {
  key: 'ConnectorName',
  name: 'ConnectorName',
  minWidth: 400,
  locStringId: connectorsStrings.ConnectorNameColumn,
  isResizable: true,
  onRender: (connector: DatasetSummary) => {
    return connector!.datasetName
  }
}

const _connectorPublisherColumn: ILocalizedColumn = {
  key: 'Publisher',
  name: 'Publisher',
  minWidth: 130,
  locStringId: connectorsStrings.ConnectorPublisherColumn,
  isResizable: true,
  onRender: (connector: DatasetSummary) =>
    (connector!.ownerApp && connector!.ownerApp.get('displayName')) || connector!.appName || consts.hyphen
}

const _connectorLastSyncDateColumn: (loc: ILocalizationApis) => ILocalizedColumn = (loc: ILocalizationApis) => {
  return {
    key: 'LastSyncTime',
    name: 'LastSyncTime',
    minWidth: 175,
    locStringId: connectorsStrings.ConnectorLastSyncColumn,
    isResizable: true,
    onRender: (connector: DatasetSummary) => {
      const datasetStatus = connector!.datasetStatus
      return (datasetStatus && convertToDateTime(connector.datasetStatus!.get('lastSyncTime'), loc)) || consts.hyphen
    }
  }
}

const _connectorModifiedDateColumn: (loc: ILocalizationApis) => ILocalizedColumn = (loc: ILocalizationApis) => {
  return {
    key: 'LastModifiedDateTime',
    name: 'LastModifiedDateTime',
    minWidth: 175,
    locStringId: connectorsStrings.ConnectorLastModifiedColumn,
    isResizable: true,
    onRender: (connector: DatasetSummary) =>
      (connector!.lastModified && convertFromEpochTime(connector.lastModified!.get('timeStamp'), loc)) ||
      convertFromEpochTime(connector.lastModifiedDate, loc) ||
      consts.hyphen
  }
}

const _connectorStatusColumn: (classNames: IProcessedStyleSet<IConnectorStyle>) => ILocalizedColumn = (
  classNames: IProcessedStyleSet<IConnectorStyle>
) => {
  return {
    key: 'Status',
    name: 'Status',
    minWidth: 200,
    locStringId: connectorsStrings.ConnectorStatusColumn,
    isResizable: true,
    onRender: (connector: DatasetSummary) => {
      const status = connector.datasetStatus
      const statusValue = status && status!.get('crawlState')

      if (!!statusValue) {
        let iconName = ''
        switch (statusValue) {
          case DataSetState.Paused:
          case DataSetState.Pausing:
            iconName = 'Pause'
            break
          case DataSetState.Deleted:
          case DataSetState.Deleting:
            iconName = 'Delete'
            break
          case DataSetState.Syncing:
            iconName = 'Sync'
            break
          case DataSetState.Failed:
            iconName = 'Error'
            break
          case DataSetState.Enabled:
            iconName = 'CircleShapeSolid'
            break
        }
        return (
          <div>
            {iconName ? (
              <span
                className={
                  statusValue === DataSetState.Failed
                    ? classNames.failedIconStyle
                    : statusValue === DataSetState.Enabled
                    ? classNames.enabledIconStyle
                    : classNames.regularIconStyle
                }
              >
                <Icon iconName={iconName} />
              </span>
            ) : null}
            <span className={iconName ? classNames.statusDescriptionStyle : ''}>
              {statusValue in DataSetState ? DataSetState[statusValue].toString() : consts.hyphen}
            </span>
          </div>
        )
      }

      return
    }
  }
}

export const connectorsItemsSelector = createSelector(
  [
    (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'connectors']),
    (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'selectedConnectorNavTypeReducer'])
  ],
  (
    connectorsState: IImmutableList<IImmutableMap<DatasetSummary & ICompositeListRowItem>>,
    navType: DatasetEditState
  ) => {
    return connectorsState
      .toArray()
      .filter((connector: IImmutableMap<DatasetSummary & ICompositeListRowItem>) => {
        // If user selects Publish nav item, then we should show both Publish and Pending Publish state connectors
        return (
          connector.get('datasetEditState') === navType ||
          (connector.get('datasetEditState') === DatasetEditState.PendingPublish &&
            navType === DatasetEditState.Published)
        )
      })
      .map((connector: IImmutableMap<DatasetSummary & ICompositeListRowItem>) => {
        return connector.toObject()
      })
  }
)

export const isFetchingItemsSelector = createSelector(
  (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'isFetchingItems']),
  (isFetching: boolean) => isFetching
)

export const errorLoadingConnectorsSelector = createSelector(
  (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'errorLoadingConnectorsReducer']),
  (errorLoadingConnectors: boolean) => errorLoadingConnectors
)

export const searchTermSelector = createSelector(
  (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'searchString']),
  (searchTerm: string) => searchTerm
)

export function getPrimaryCommandBasedOffSelection(): ICommandBarItemProps[] {
  const addOffice365UDTConnectors: ICommandBarItemProps = {
    key: 'addUDTConnector',
    name: 'Add',
    iconProps: { iconName: 'Add' },
    buttonStyles: getCommandBarActiveItemStyle()
  }

  const refreshList: ICommandBarItemProps = {
    key: 'refreshList',
    name: 'Refresh',
    iconProps: { iconName: 'Refresh' },
    itemProps: {
      styles: getCommandBarContextMenuItemStyles()
    },
    buttonStyles: getCommandBarItemStyle()
  }

  const commandBarPrimaryItems: ICommandBarItemProps[] = [addOffice365UDTConnectors, refreshList]
  return commandBarPrimaryItems
}

export const connectorsActionItemRendererSelector = createSelector(connectorsItemsSelector, () => {
  return () => {
    return []
  }
})

// TODO 1067760: Commonalize code b/w Groups and Connectors
export const connectorEmptyListSelector = (classNames: IProcessedStyleSet<IConnectorStyle>) =>
  createSelector(
    (_state: AppState, props: ILocalizedComponent) => props.loc,
    errorLoadingConnectorsSelector,
    isFetchingItemsSelector,
    connectorsItemsSelector,
    searchTermSelector,
    (
      loc: ILocalizationApis,
      loadingConnectorsError: boolean,
      fetchingItems: boolean,
      connectorItems: DatasetSummary[],
      searchTermText: string
    ) => {
      if (!fetchingItems && loadingConnectorsError) {
        return (
          <div>
            <div className={classNames.noResultsMessageStyle}>
              {loc.fmtMsg(connectorsStrings.EmptyList_ErrorHeader)}
            </div>
            <div className={classNames.clearSearchMessageStyle}>
              {loc.fmtMsg(connectorsStrings.EmptyList_ErrorInfo)}
            </div>
          </div>
        )
      } else if (!fetchingItems && connectorItems.length === 0 && searchTermText === '') {
        return (
          <div>
            <div className={classNames.noResultsMessageStyle}>{loc.fmtMsg(connectorsStrings.EmptyList_Header)}</div>
            <div className={classNames.clearSearchMessageStyle}>{loc.fmtMsg(connectorsStrings.EmptyList_Info)}</div>
          </div>
        )
      } else if (!fetchingItems && connectorItems.length === 0) {
        return (
          <div>
            <div className={classNames.noResultsMessageStyle}>{loc.fmtMsg(connectorsStrings.EmptyResult_Header)}</div>
            {searchTermText !== '' && (
              <div className={classNames.clearSearchMessageStyle}>
                {loc.fmtMsg(connectorsStrings.EmptyResult_ClearSearch)}
              </div>
            )}
          </div>
        )
      } else {
        return undefined
      }
    }
  )

export const interimFarItemSelector = (_classNames: IProcessedStyleSet<IConnectorStyle>) =>
  createSelector([(_state: AppState, props: ILocalizedComponent) => props.loc], (loc: ILocalizationApis): ((
    defaultRender: (options: ICompositeListFarItemOptions) => ICommandBarItemProps[]
  ) => ICommandBarItemProps[]) => {
    return (defaultRender: (options: ICompositeListFarItemOptions) => ICommandBarItemProps[]) => {
      const defaultItems = defaultRender({
        compactMenuProps: {
          key: commandBarLabels.DisplayListMenu,
          title: loc.fmtMsg(connectorsStrings.ChangeView),
          ariaLabel: loc.fmtMsg(connectorsStrings.CommandBarRolesAriaLabel)
        },
        compactMenuCompactListItemProps: {
          key: commands.DisplayListCompact,
          text: loc.fmtMsg(connectorsStrings.CommandBarCompactList)
        },
        compactMenuNormalListItemProps: {
          key: commands.DisplayListRelaxed,
          text: loc.fmtMsg(connectorsStrings.Cmd_NormalList)
        },
        searchBoxProps: {
          ariaLabel: loc.fmtMsg(connectorsStrings.ConnectorSearchAriaLabel),
          placeholder: loc.fmtMsg(connectorsStrings.ConnectorSearchPlaceholder)
        }
      })

      return defaultItems
    }
  })

export const isCompactModeSelector = createSelector(
  (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'isCompactMode']),
  (isCompactModeSet: boolean) => isCompactModeSet
)

export const commandBarPrimaryItemsSelector = createSelector(
  [(state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'selectedConnectorItemsCount'])],
  getPrimaryCommandBasedOffSelection
)

export const selectedDatasetSelector = createSelector(
  (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'selectedDataSet']),
  (selectedDataSet: IImmutableMap<DatasetDetail>) => selectedDataSet
)

// Since the SelectedDataset can be an empty entity, this is specifically needed to check if there
// Is a selected item.
export const selectedDatasetIdSelector = createSelector(
  (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'selectedDataSet']),
  (selectedDataSet: IImmutableMap<DatasetDetail>) => selectedDataSet!.get('datasetId')
)

export const selectedDatasetEditState = createSelector(
  [selectedDatasetSelector],
  (selectedDataSet: IImmutableMap<DatasetDetail>) => selectedDataSet!.get('datasetEditState')
)

export const isDatasetPublished = createSelector(
  [selectedDatasetEditState],
  (datasetEditState: DatasetEditState) => datasetEditState === DatasetEditState.Published
)

export const selectedDatasetProviderIdSelector = createSelector(
  [selectedDatasetSelector],
  (selectedDataset: IImmutableMap<DatasetDetail>) => selectedDataset.get('providerId')
)

export const selectedDatasetRefreshSettings = createSelector(
  [selectedDatasetSelector],
  (selectedDataSet: IImmutableMap<DatasetDetail>) => selectedDataSet!.get('refreshSetting')
)

export const selectedDatasetIncrementalCrawlInterval = createSelector(
  [selectedDatasetRefreshSettings],
  (selectedDatasetRefreshSettingsValue: IImmutableMap<RefreshSetting> | undefined) =>
    selectedDatasetRefreshSettingsValue && selectedDatasetRefreshSettingsValue!.get('incrementalSyncInterval')
)

export const selectedDatasetIncrementalCrawlText = createSelector(
  [selectedDatasetIncrementalCrawlInterval, locApiSelector],
  (incrementalRefreshInterval: number | undefined, loc: ILocalizationApis) => {
    if (!incrementalRefreshInterval) {
      return consts.hyphen
    }
    return getRefreshScheduleOptionsForCrawlFrequency(loc, CrawlFrequency.None, incrementalRefreshInterval) as string
  }
)

export const selectedDatasetFullCrawlInterval = createSelector(
  [selectedDatasetRefreshSettings],
  (selectedDatasetRefreshSettingsValue: IImmutableMap<RefreshSetting> | undefined) =>
    selectedDatasetRefreshSettingsValue && selectedDatasetRefreshSettingsValue!.get('fullSyncInterval')
)

export const selectedDatasetFullCrawlText = createSelector(
  [selectedDatasetFullCrawlInterval, locApiSelector],
  (fullRefreshInterval: number | undefined, loc: ILocalizationApis) => {
    if (!fullRefreshInterval) {
      return consts.hyphen
    }
    return getRefreshScheduleOptionsForCrawlFrequency(loc, CrawlFrequency.None, fullRefreshInterval) as string
  }
)

export const selectedDatasetAcls = createSelector(
  [selectedDatasetSelector],
  (selectedDataset: IImmutableMap<DatasetDetail>) => selectedDataset.get('aclSetting')
)

export const selectedDatasetAclsDisplayNames = createSelector(
  [selectedDatasetAcls, locApiSelector, selectedDatasetProviderIdSelector],
  (aclSetting: IImmutableMap<AclSetting> | undefined, loc: ILocalizationApis, providerId: string) => {
    if (aclSetting) {
      if (isFileConnector(providerId)) {
        return loc.fmtMsg(connectorsStrings.Honouring_Source_Acls)
      }

      // If we have to use system level ACLS, we skip further checks
      if (aclSetting.get('useItemLevelAcl') === true) {
        return loc.fmtMsg(connectorsStrings.Limited_Access_Control)
      }
    }

    // No acl Setting is equivalent to everyone.
    return loc.fmtMsg(connectorsStrings.Visible_To_Everyone)
  }
)

export function getConnectorItemIdKey(item: DatasetSummary, index: number): string {
  if (item) {
    return item.datasetId
  }
  return index.toString()
}

// TODO 1067760: Commonalize code b/w Groups and Connectors
function localizeNamedItem<T extends ILocalizedItem>(items: T[], loc: ILocalizationApis): T[] {
  return items.map((item: T) => {
    if (item.locStringId) {
      item.name = loc.fmtMsg(item.locStringId)
    }
    return item
  })
}

export function onConnectorListRenderRow<T extends ICompositeListRowItem>(
  // tslint:disable-next-line:no-any
  rowProps: IDetailsRowProps & { selection: ISelection; getKey: (item: any) => string },
  defaultRender: IRenderFunction<IDetailsRowProps>,
  actionItems: IActionButtonProps<T>[]
): JSX.Element {
  return (
    <CompositeListRow
      actionKey="ConnectorName"
      renderFunction={defaultRender}
      rowProps={rowProps}
      actionItems={actionItems}
      selection={rowProps.selection}
      getKey={rowProps.getKey}
    />
  )
}

const columnsListComplete: (
  loc: ILocalizationApis,
  classNames: IProcessedStyleSet<IConnectorStyle>
) => ILocalizedColumn[] = (loc: ILocalizationApis, classNames: IProcessedStyleSet<IConnectorStyle>) => {
  return [
    _connectorNameColumn,
    _connectorPublisherColumn,
    _connectorLastSyncDateColumn(loc),
    _connectorModifiedDateColumn(loc),
    _connectorStatusColumn(classNames)
  ]
}

// TODO 1067760: Commonalize code b/w Groups and Connectors
const columnsListCompleteSelector = (classNames: IProcessedStyleSet<IConnectorStyle>) =>
  createSelector(locApiSelector, (loc: ILocalizationApis) =>
    localizeNamedItem(columnsListComplete(loc, classNames), loc)
  )

// TODO 1067760: Commonalize code b/w Groups and Connectors
function getShownColumns(shownColumns: IImmutableList<string>, completeColumns: IColumn[]): IColumn[] {
  const columns: IColumn[] = []

  shownColumns.forEach((shownColumn: string) => {
    const i = completeColumns.findIndex((column: IColumn) => column.key === shownColumn)
    if (i > -1) {
      columns.push(completeColumns[i])
    }
  })

  return columns
}

export const connectorsColumnsSelector = (classNames: IProcessedStyleSet<IConnectorStyle>) =>
  createSelector(
    [
      (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'shownColumns']),
      columnsListCompleteSelector(classNames)
    ],
    getShownColumns
  )

export const selectedConnectorNavTypeSelector = createSelector(
  (state: AppState) => state.getIn(['microsoftSearch', 'connectorList', 'selectedConnectorNavTypeReducer']),
  (selectedNav: DatasetEditState) => selectedNav
)
